# De Novo Assembly and Overlap-Layout-Consensus (OLC)

**Group 21:**
Yanjun Huang
Chang Liu
Shengjun You

---

# Background
After human genome was successfully sequenced in the Human Genome Project, in recent years, extensive studies have been done to develop genome sequencing techniques and apply them to understand the genetic basis of human biology. The growing popularity of genomic research gives rise to the need for sequencing techniques that are faster, more accurate, and cost less. Under these requirements, next generation sequencing(NGS) techniques were invented and were able to sequence the entire human genome as fast as within a single day (Behjati et al., 2013). 

However, enormous “reads” of short DNA fragments would be outputted by NGS, and processing and these reads can be expensive in both time and space. In bioinformatics studies, sequence assembly is an important step that deals with the reads provided by sequencing techniques. In order to facilitate genomic research, one of the major concerns in the field is developing less error-prone assembly techniques that can efficiently process the large data generated by NGS. In this report, we will introduce one of the assembly techniques called de novo assembly and an algorithm termed OLC which is commonly used to conduct de novo assembly. 



---

# NGS and Sequence Assembly 
Although there are numerous techniques that can carry out next generation sequencing, some key features shared by these techniques include: 

1. The entire genome is broken into fragments that are dozens of or hundreds of bases in length.
2. Millions of short DNA fragments would then be sequenced in parallel(Behjati et al., 2013), a process termed as "massive parallel sequencing".

Once the short fragments are sequenced, these reads will be used to conduct **sequence assembly**, which aims to reconstruct the genome sequence by merging reads of the short DNA fragments. 

<p align="center">
  <img width="300" height="400" src="https://i.imgur.com/rksfCzp.png">
</p>
<div align = "center">
<font size = "2">https://research.medgenome.com/ngs-tab1/
 </font>
</div>


---

# Two Types of Assembly Techniques
In general, there are two types of assembly techniques:
## Mapping Assembly
A genome with known sequence is used as the reference when performing mapping assembly. Each fragment is aligned to the reference genome to find out where it is most likely to be found, and then the fragment is mapped to that position. 

Mapping assembly is commonly practiced in:
* **RNA-seq**: Gene expression level is quantified as the number of cDNA fragments mapped to the gene's locus on the reference genome.
* **ChIP-Seq**: DNA fragments are mapped to the reference genome so as to identify which genes can bind to the transcription factor of interest. 
* **Variant Calling**: Compare the assembled genome with the reference to identify genetic variants and the cause of genetic diseases. 

<p align="center">
  <img width="400" height="200" src="https://i.imgur.com/aXUcKQE.jpg">
</p>
<div align = "center">
<font size = "2">https://www.baseclear.com/wp-content/uploads/Computational-methods-for-metatranscriptome-analysis.png
 </font>
</div>

## De novo Assembly 
In contrast to mapping assembly, de novo assembly doesn't require a reference genome. Scientists have no prior knowledge of the genome that they're about to reconstruct and can only rely on information from the reads. Therefore, de novo assembly methods are designed based on the assumption that the  reads covering "the examined part of a genome" are "overlapping one another", and reconstruct the genome by "utilizing the information from the overlaps" (Swiercz et al., 2018). 

De novo assembly is commonly practiced in:
* **DNA sequencing**: Scientists usually have no prior knowledge of the genome that they are working on when practicing DNA sequencing. De novo assembly is particularly useful in sequencing the genome of novel species or strains. 

<p align="center">
  <img width="400" height="200" src="https://i.imgur.com/GrtoO8f.jpg">
</p>
<div align = "center">
<font size = "2">https://slideplayer.com/slide/6828255/23/images/2/Genomic+DNA+Shotgun+reads+Contigs+Complete+sequence.jpg
 </font>
</div>

# Algorithm in De novo Assembly
There are 2 common challenges one may encounter when developing a de novo assembly algorithm: 
1. **Requires a lot of memory space**: Since we start from scratch, we require a large number of reads to form a complete assembly. This will lead to a high memory cost. 
2. **Huge time cost**: We will meet many complicated situations that are likely to drastically increase the runtime of the algorithm, such as encountering repeat region and heterozygosity. 

Bioinformaticians are developing new algorithms that can handle these 2 challenges, and as of now two major types of algorithms are created: **standard greedy algorithms** and **greedy algorithms in graph**.

## Standard greedy algorithms
By practicing **greedy algorithms**, we break a problem into numerous step-by-step attempts, and in each attempt the best choice that serves the purpose would be selected. **Standard greedy algorithms** are one of the first methods used in sequence assembly, and these algorithms do not utilize graphs to organize reads. 

**Shortest common superstring** is one algorithm created based on the standard greedy algorithm. Shortest common superstring will find two reads with largest overlap -- that's the best choice we can make in each attempt. Then these 2 reads will be merged into one. This process of finding 2 reads with largest overlap and merging is repeated until there is no overlap exist in all reads. 

The algorithms described above can assemble short genome and many earlier assemble tools use standard greedy algorithms. However, many misassemble will arise as we assemble larger genome with longer repeat regions with standard greedy algorithms.  We need better algorithms.

## Greedy algorithms in graph
Obviously, **greedy algorithms in graph** require help from graphs. Graph is a set of nodes with edges connecting them. If edges in a graph can only go from one node to the other, this graph is a directed graph (Miller et al., 2010), i.e. edge one goes from node A to node B and edge two goes from B to A. An example of directed graph is demonstrated below:

<p align="center">
  <img width="300" height="200" src="https://i.imgur.com/91U8NZj.png">
</p>
<div align = "center">
<font size = "2">https://commons.wikimedia.org/wiki/File:Directed_graph.svg
 </font>
</div>

Unlike standard greedy algorithms which assemble steps by steps, graph algorithms will gather information of all reads and transform it into a graph. By constructing the graph, we have the opportunity to see the genome as a whole instead of parts. Many different algorithms for assembly are formed by differentially defined vertices and edges. 

Two of the most commonly used greedy algorithms in graph are:

1. **Overlap-Layout-Consensus (OLC)**: OLC was introduced at the end of the 20th century. The algorithm is based on the help of an overlap graph. Since this chapter is mainly focused on this algorithm, we can see the later parts of this chapter for details about this algorithm.

<p align="center">
  <img width="300" height="300" src="https://i.imgur.com/LAHNLaY.jpg">
</p>
<div align = "center">
<font size = "2">https://commons.wikimedia.org/wiki/File:OLC,Overlap-Layout-consensus.png
 </font>
</div>


2. **de Bruijn graph assembly**: also known as kmer assembly. Unlike OLC which keeps information of each read, de Bruijn graph breaks reads into kmers, a nucleotide sequence of length k. Graph is constructed with each vertex as the overlap region of each kmers (k-1 bp) and each edge as one kmer. Constructing graphs using kmers instead of raw reads will merge similar edges automatically. This enables de Bruijn to simplify the graph with multiple reads covering the same position, which makes de Bruijn graph algorithm good at handling genome assembly with high coverage. 

<p align="center">
  <img width="450" height="300" src="https://i.imgur.com/BpJgidO.png">
</p>
<div align = "center">
<font size = "2">https://homolog.us/Tutorials/book4/p2.1.html
 </font>
</div>

There are many other algorithms, and people also make various attempts to improve existing algorithms in order to use less time but achieve better results.


---
# OLC: Overlap-Layout-Consensus
In this section, details of the OLC algorithm will be explained so as to exemplify how to design a sequence assembly algorithm with the use of greedy algorithms in graph. 

As introduced above, the underlying rationale of greedy algorithms in graph is gathering information from all reads and converting it into a graph. Therefore, all 3 steps of OLC (**overlap**, **layout**, and **consensus**) are designed to reconstruct the genome by consulting with the graph we build. 

<p align="center">
  <img width="600" height="250" src="https://i.imgur.com/L6jh7Zz.png">
</p>


<div align = "center">
<font size = "2">(Langmead, n.d.)
 </font>
</div>


## Overlap: Build overlap graph
The first step of OLC aims to build a special directed graph called the "overlap graph". It tells us which fragments are overlapped. 

In this overlap graph, each read represents a node. Edges are created by the following procedures:
1. define an overlapping threshold integer **L** 
2. examine every pair of reads 
3. If the suffix of the first read overlaps with the prefix of the second read by at least **L** bases, create a directed edge from the first read to the second read in the graph. 

In the example shown below, suppose there are several reads: **GGCT**, **GCTA**, **ACAC**, and the threshold is defined to be **L** = 3. After examining every pair of reads, we find that the following 2 pairs have overlapped bases:

<p align="center">
  <img width="300" height="100" src="https://i.imgur.com/2u1oqBZ.jpg">
</p>

On the left, the pair of reads are overlapped by exactly 3 bases. Since the threshold is reached, in the overlapping graph we create a directed edge from **GGCT** to **GCTA**. However, on the right, the pair of reads are overlapped by only 1 base. Since this pair doesn't meet the threshold, there's no edge directed from **GCTA** to **ACAC** in the graph. 

Therefore, below is the overlap graph for this example:

<p align="center">
  <img height = "100" width = "350" src="https://i.imgur.com/xz5BvyO.jpg">
</p>


## Layout: Bundle stretches of the overlap graph into contigs

After building the overlap graph, we will proceed to the next step layout. During this process, the overlap graph will be processed and converted into contigs. The overall goal here is to find a simple path that only contains distinct nodes, i.e. each node is visited at most once.

Overlap graphs can be big and messy. We will take the graph for the string <span style="color:#CD5C5C">"to_every_thing_turn_turn_turn_there_is_a_season"</span> as an example (Langmead, n.d.). We can imagine these are nucleotide sequences. In the graph below, each node represents a read with length 7 and each edge represents that the two nodes have at least 4 overlapping elements, i.e. the overlapping threshold is 4. As we can see, this graph is extremely messy. So, how can we make this cleaner? 

<p align="center">
  <img width="600" height="250" src="https://i.imgur.com/6lDHFkF.png">
</p>

We will remove edges that can be inferred from other edges. The small example below shows that we can go from node one to node three without going through node two, because there are shared elements <span style="color:#CD5C5C">"cde"</span> in both one and three. Similarly, we can apply this idea to the big messy graph shown above. 

<p align="center">
  <img width="400" height="160" src="https://i.imgur.com/aEbPzCh.png">
</p>

And then, more nodes can be skipped since they can be inferred from the others. After reduction, we can obtain a linear sequence with some messy parts in the middle, as shown in the graph below (Langmead, n.d.). The green and blue boxes show a linear structure in which there is only one path from the starting node to the end. And these are the simple paths, or contigs, that we are looking for. However, the red part in the middle is still messy. This happens due to <span style="color:#CD5C5C">"turn_turn_turn"</span>, the repeat in the original sequence. 

<p align="center">
  <img width="400" height="120" src="https://i.imgur.com/YxTNU6S.png">
</p>

<p align="center">
  <img width="600" height="80" src="https://i.imgur.com/M2n0RVg.png">
</p>

Repeats are regions where one single read cannot span the entire repeated sequence. Nodes or reads for this area are highly similar, i.e. <span style="color:#CD5C5C">"turn_tu" </span> and <span style="color:#CD5C5C"> "urn_tur"</span>. This will increase computation time as reads have many overlaps with other reads from this area, i.e. there are multiple paths between those nodes. One solution to this problem is to mask the repeat regions before or during the overlap step first and then recover it after contig construction (Li et al., 2012). Through this preprocessing step, we can make sure that no repeated regions exist in the overlap graph, which will prevent messy areas, like the red box above, from happening. Another way to resolve repeats is to increase the overlap threshold **L** (Li et al., 2012). When **L** is larger than the length of any repeats, one node can cover the entire repeated sequence. To do this, we need to have a larger read length (**T**), as **T** is the upper bound for **L** (Li et al., 2012). And this is why OLC works better with longer reads. 

Besides repeats, layout also has to process reads with sequencing error. In the example demonstrated below (Langmead, n.d.), the dark blue blocks represent shared bases, and the light blue box represents a unique nucleotide base. While read B shares some common sequences with other reads, the shared part ends abruptly at the light blue box. Therefore, we might conclude that read B has a sequencing error. And we will prune it.

<p align="center">
  <img width="400" height="200" src="https://i.imgur.com/7XFBmtJ.png">
</p>

## Consensus: Pick most likely nucleotide sequence for each contig

After obtaining contigs from layout, we will proceed into the consensus step. The main idea here is that **the majority wins**. First, we will pick reads that make up a contig and line them up. Then, the most common base at that position will be chosen and be used for further analysis. In the example demonstrated below (Langmead, n.d.), the red T and C nucleotide in read three is different from other reads. Therefore, the most common bases at that position, C and G respectively, will be chosen for genome assembly. 

<p align="center">
  <img width="400" height="200" src="https://i.imgur.com/GmfAL4D.png">
</p>


---

# Advantages and Disadvantages

## Major Advantages - Complete reads informations
The OLC algorithm will have more complete reads information than many other algorithms which reads are split into substrings to form a more simplified graph. For instance, de Bruijn split reads into kmers which is usually much shorter than reads. This might cause loss of information about reads. Oppositely, OLC algorithm stores each read as a vertex in the overlap graph. This enables the overlap graph to contain more complete read information.

## Major Disadvantages - Large memory and time cost
Like we described in the previous part, OLC will record every single read as a vertex in the overlap graph. Creating this vertex and linking it to reads mapped to it will take a long time. And storing these vertices and edges will take a considerable amount of memory. Especially when the raw data have a large number of reads with high coverage among genome, this problem will be very severe since we have limited memory and want to take shorter time during assembly.

In most of the cases, we have the problem of limited resource (memory and CPU) and time for assembly which consist very large number of reads. The cost might put us in a very embarrassed situation. So why are we still using OLC?

# Why Overlap-layout-consensus?
OLC is first introduced to handle reads from Sanger sequencing. Sanger sequencing has long reads with high accuracy, so we do not need huge number reads to support a complete assembly. This makes the OLC algorithm prevalent at the beginning of computational assembly.

However, new sequencing technologies are emerging rapidly in the following decades. Next generation sequencing (NGS) is taking over the work of assembling large genomes from Sanger sequencing. The new technology brings much higher throughput, or larger number of reads, but it also limits length of reads to less than 300 base pairs (bps). The short reads sequencing requires huge numbers of reads to assemble a genome. The large number of short reads will take too much time and memory if we choose to assemble with the OLC algorithm. de-Bruijn graph algorithm takes over its place in assembly by splitting reads into shorter fragments as kmers which leads to much less memory cost. Although there is also a problem with de-Bruijn graph that kmers' length are usually at most 127 bps, it is enough to out-compete OLC algorithms in the era of Next Generation Sequencing.

Time goes on, many improvements on OLC algorithm are made, and longer sequencing technologies are created. The Third Generation Sequencing technologies provide us much longer reads. As the reads get longer, it becomes a lost to split reads into 127 bps long kmers. People are more interested in keeping complete reads informations. Therefore, the advantage of OLC algorithm which keep all reads information takes it back to people's sight. Moreover, as the reads get longer, we do not require huge number of reads to achieve high coverage. This directly reduced memory cost for OLC algorithm. And in the past decade, varies ways of reductions are introduced, which shorten the runtime for applying OLC algorithm. As we can see, most of its disadvantages are covered by the advanced technology and the wisdom of many smart bioinformaticians. The longer reads handle the problem of large memory cost, and it might also create better results when we meet long repeat regions. The improvements on algorithms make it possible to complete assembly in a shorter time. Since OLC assemble reads are well suited to current technology, I believe it will be one of the assembling methods prevalent in the present and future. And this is the reason why we choose to introduce you to this algorithm.



---
# Reference
Behjati, S., & Tarpey, P. S. (2013). What is next generation sequencing?. Archives of disease in childhood. *Education and practice edition*, 98(6), 236–238. https://doi.org/10.1136/archdischild-2013-304340

Compeau, P. E., Pevzner, P. A., & Tesler, G. (2011). How to apply de Bruijn graphs to genome assembly. *Nature biotechnology*, 29(11), 987–991. https://doi.org/10.1038/nbt.2023

Giani, A. M., Gallo, G. R., Gianfranceschi, L., & Formenti, G. (2019). Long walk to genomics: History and current approaches to genome sequencing and assembly. *Computational and structural biotechnology journal*, 18, 9–19. https://doi.org/10.1016/j.csbj.2019.11.002

Langmead, B.(n.d.). *Assembly in Practice: Part 1: OLC*. Langmead Lab, www.cs.jhu.edu/~langmea/resources/lecture_notes/18_assembly_olc_v2.pdf. 

Li, Z., Chen, Y., Mu, D., Yuan, J., Shi, Y., Zhang, H., Gan, J., Li, N., Hu, X., Liu, B., Yang, B., & Fan, W. (2012). Comparison of the two major classes of assembly algorithms: Overlap–layout–consensus and de-bruijn-graph. *Briefings in Functional Genomics*, 11(1), 25–37, https://doi.org/10.1093/bfgp/elr035

Miller, J. R., Koren, S., & Sutton, G. (2010). Assembly algorithms for next-generation sequencing data. *Genomics*, 95(6), 315–327. https://doi.org/10.1016/j.ygeno.2010.03.001

Swiercz, A., Frohmberg, W., Kierzynka, M., Wojciechowski, P., Zurkowski, P., Badura, J., Laskowski, A., Kasprzak, M., & Blazewicz, J. (2018). GRASShopPER—An algorithm for de novo assembly based on GPU alignments. *PLOS ONE*, 13(8), e0202355. https://doi.org/10.1371/journal.pone.0202355
